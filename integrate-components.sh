#!/bin/bash
# OpenCog Unified Component Integration Script
# This script automates the cloning and integration of OpenCog components

set -e

# Configuration
COMPONENTS_DIR="components"
REPOS_BASE_URL="https://github.com/opencog"

# Component definitions with dependencies
declare -A COMPONENTS
COMPONENTS=(
    ["atomspace-rocks"]="core:atomspace"
    ["atomspace-restful"]="core:atomspace"
    ["unify"]="logic:atomspace"
    ["ure"]="logic:atomspace,unify"
    ["attention"]="cognitive:atomspace,cogserver"
    ["spacetime"]="cognitive:atomspace"
    ["pln"]="advanced:atomspace,ure,spacetime"
    ["miner"]="advanced:atomspace,ure"
    ["moses"]="learning:cogutil"
    ["asmoses"]="learning:atomspace,ure"
    ["lg-atomese"]="language:atomspace"
    ["learn"]="language:atomspace,cogserver"
    ["language-learning"]="language:cogutil"
    ["opencog"]="integration:atomspace,cogserver,attention,ure,lg-atomese"
)

# Phase definitions
declare -A PHASES
PHASES=(
    [1]="atomspace-rocks,atomspace-restful,moses"
    [2]="unify,ure,language-learning"
    [3]="attention,spacetime"
    [4]="pln,miner,asmoses"
    [5]="lg-atomese,learn,opencog"
)

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Create directory structure
create_directories() {
    log_info "Creating directory structure..."
    mkdir -p ${COMPONENTS_DIR}/{core,logic,cognitive,advanced,learning,language,integration}
    mkdir -p tests/{integration,performance,end_to_end}
    mkdir -p docs/integration
    log_success "Directory structure created"
}

# Clone a single component
clone_component() {
    local component=$1
    local category=$(echo ${COMPONENTS[$component]} | cut -d: -f1)
    local target_dir="${COMPONENTS_DIR}/${category}/${component}"
    
    log_info "Cloning ${component} into ${target_dir}..."
    
    if [ -d "$target_dir" ]; then
        log_warning "${component} already exists, skipping clone"
        return 0
    fi
    
    # Monorepo approach: clone and integrate as folder
    git clone "${REPOS_BASE_URL}/${component}.git" "$target_dir"
    
    if [ $? -eq 0 ]; then
        # Remove .git directory to integrate as monorepo folder
        rm -rf "$target_dir/.git"
        log_success "Successfully cloned and integrated ${component} as monorepo folder"
        return 0
    else
        log_error "Failed to clone ${component}"
        return 1
    fi
}

# Check if dependencies are satisfied
check_dependencies() {
    local component=$1
    local deps=$(echo ${COMPONENTS[$component]} | cut -d: -f2)
    
    if [ "$deps" = "${COMPONENTS[$component]}" ]; then
        return 0  # No dependencies
    fi
    
    IFS=',' read -ra DEP_ARRAY <<< "$deps"
    for dep in "${DEP_ARRAY[@]}"; do
        # Check if dependency exists in current repo or components directory
        if [ ! -d "$dep" ] && [ ! -d "${COMPONENTS_DIR}/*/${dep}" ]; then
            log_error "Dependency $dep not found for $component"
            return 1
        fi
    done
    
    return 0
}

# Generate CMake integration for a component
generate_cmake_integration() {
    local component=$1
    local category=$(echo ${COMPONENTS[$component]} | cut -d: -f1)
    local deps=$(echo ${COMPONENTS[$component]} | cut -d: -f2)
    
    cat >> CMakeLists_integration.txt << EOF

# ${component} integration
if(EXISTS "\${CMAKE_CURRENT_SOURCE_DIR}/${COMPONENTS_DIR}/${category}/${component}/CMakeLists.txt")
    add_subdirectory(${COMPONENTS_DIR}/${category}/${component})
    
    # Add dependencies
EOF

    if [ "$deps" != "${COMPONENTS[$component]}" ]; then
        IFS=',' read -ra DEP_ARRAY <<< "$deps"
        for dep in "${DEP_ARRAY[@]}"; do
            echo "    add_dependencies(${component} ${dep})" >> CMakeLists_integration.txt
        done
    fi
    
    echo "endif()" >> CMakeLists_integration.txt
}

# Create integration test template
create_integration_test() {
    local component=$1
    local test_file="tests/integration/test_${component}.py"
    
    cat > "$test_file" << EOF
#!/usr/bin/env python3
"""
Integration test for ${component} component
Generated by OpenCog Unified integration script
"""

import unittest
import sys
import os

# Add paths for component testing
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', '${COMPONENTS_DIR}'))

class Test${component^}Integration(unittest.TestCase):
    """Test ${component} integration with OpenCog Unified"""
    
    def setUp(self):
        """Set up test environment"""
        pass
        
    def test_${component}_import(self):
        """Test that ${component} can be imported"""
        try:
            # Attempt to import the component module
            import importlib
            module = importlib.import_module("${component}")
            self.assertIsNotNone(module, "${component} module should be importable")
        except ImportError as e:
            self.fail(f"Failed to import {component}: {e}")
        
    def test_${component}_basic_functionality(self):
        """Test basic ${component} functionality"""
        try:
            # Test basic component functionality
            # This is a generic test that can be customized per component
            import importlib
            module = importlib.import_module("${component}")
            
            # Check if module has expected attributes/methods
            self.assertTrue(hasattr(module, '__file__'), 
                          "${component} should have __file__ attribute")
            
            # Additional component-specific tests can be added here
            # based on the component's expected interface
            
        except Exception as e:
            self.fail(f"Basic functionality test failed for {component}: {e}")
        
    def test_${component}_dependencies(self):
        """Test ${component} dependency integration"""
        try:
            # Test component dependency integration
            import importlib
            module = importlib.import_module("${component}")
            
            # Check if required dependencies are available
            # This can be customized based on component requirements
            if hasattr(module, '__requires__'):
                for dep in module.__requires__:
                    try:
                        importlib.import_module(dep)
                    except ImportError:
                        self.fail(f"Required dependency {dep} not available for {component}")
            
            # Test that component can be instantiated/used
            # This is a basic integration test
            self.assertTrue(True, f"{component} dependency integration test passed")
            
        except Exception as e:
            self.fail(f"Dependency integration test failed for {component}: {e}")

if __name__ == '__main__':
    unittest.main()
EOF

    log_info "Created integration test for ${component}: ${test_file}"
}

# Clone components for a specific phase
clone_phase() {
    local phase=$1
    log_info "Starting Phase ${phase} integration..."
    
    IFS=',' read -ra COMPONENT_ARRAY <<< "${PHASES[$phase]}"
    
    for component in "${COMPONENT_ARRAY[@]}"; do
        if ! check_dependencies "$component"; then
            log_error "Dependencies not satisfied for $component"
            continue
        fi
        
        clone_component "$component"
        generate_cmake_integration "$component"
        create_integration_test "$component"
    done
    
    log_success "Phase ${phase} cloning completed"
}

# Run integration validation
validate_integration() {
    local component=$1
    log_info "Validating ${component} integration..."
    
    # Check if CMakeLists.txt exists
    local category=$(echo ${COMPONENTS[$component]} | cut -d: -f1)
    local cmake_file="${COMPONENTS_DIR}/${category}/${component}/CMakeLists.txt"
    
    if [ ! -f "$cmake_file" ]; then
        log_warning "No CMakeLists.txt found for ${component}"
        return 1
    fi
    
    # Run integration test
    local test_file="tests/integration/test_${component}.py"
    if [ -f "$test_file" ]; then
        python3 "$test_file"
        if [ $? -eq 0 ]; then
            log_success "${component} integration validation passed"
        else
            log_error "${component} integration validation failed"
            return 1
        fi
    fi
    
    return 0
}

# Build system integration
update_main_cmake() {
    log_info "Updating main CMakeLists.txt with component integrations..."
    
    if [ -f "CMakeLists_integration.txt" ]; then
        # Backup original
        cp CMakeLists.txt CMakeLists.txt.backup
        
        # Append integration configurations
        cat CMakeLists_integration.txt >> CMakeLists.txt
        
        log_success "CMakeLists.txt updated with component integrations"
    else
        log_warning "No integration configurations generated"
    fi
}

# Main execution
main() {
    local phase=${1:-"all"}
    local action=${2:-"clone"}
    
    log_info "OpenCog Unified Component Integration Script"
    log_info "Phase: $phase, Action: $action"
    
    create_directories
    
    # Initialize integration cmake file
    echo "# OpenCog Component Integrations" > CMakeLists_integration.txt
    echo "# Generated by integration script" >> CMakeLists_integration.txt
    
    if [ "$phase" = "all" ]; then
        for p in {1..5}; do
            clone_phase $p
        done
    elif [[ "$phase" =~ ^[1-5]$ ]]; then
        clone_phase $phase
    else
        log_error "Invalid phase: $phase. Use 1-5 or 'all'"
        exit 1
    fi
    
    if [ "$action" = "build" ]; then
        update_main_cmake
        log_info "Building unified system..."
        mkdir -p build
        cd build
        cmake ..
        make -j$(nproc)
        cd ..
    fi
    
    log_success "Integration script completed successfully!"
}

# Help function
show_help() {
    cat << EOF
OpenCog Unified Component Integration Script

Usage: $0 [PHASE] [ACTION]

PHASE:
    1-5     Run specific phase (1=Core, 2=Logic, 3=Cognitive, 4=Advanced, 5=Language)
    all     Run all phases (default)

ACTION:
    clone   Clone and setup components (default)
    build   Clone, setup, and build unified system
    
Examples:
    $0              # Clone all components
    $0 1            # Clone Phase 1 components only
    $0 all build    # Clone all components and build
    $0 2 build      # Clone Phase 2 components and build

Component Phases:
    Phase 1 (Core): atomspace-rocks, atomspace-restful, moses
    Phase 2 (Logic): unify, ure, language-learning
    Phase 3 (Cognitive): attention, spacetime
    Phase 4 (Advanced): pln, miner, asmoses  
    Phase 5 (Language): lg-atomese, learn, opencog
EOF
}

# Parse command line arguments
if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    show_help
    exit 0
fi

main "$@"